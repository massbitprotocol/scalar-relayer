use ethers::prelude::*;
use ethers::{contract::Contract, types::transaction::eip2718::TypedTransaction};
use hex::FromHex;
use k256::{
    ecdsa::{SigningKey, VerifyingKey},
    schnorr::signature::Verifier,
    SecretKey,
};
use scalar_relayer::{abis::ScalarGateway, OWNER_PRIVATE_KEY};
use std::sync::Arc;
use tracing::{info, Level};
use web3::ethabi::Token;
fn set_up_logs() {
    let subscriber = tracing_subscriber::fmt()
        //.with_max_level(Level::DEBUG)
        .with_max_level(Level::INFO)
        .finish();
    tracing::subscriber::set_global_default(subscriber).expect("setting default subscriber failed");
}
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    set_up_logs();
    let execute_param ="000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000002e000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000001cecce1a2e9fd648d0228ef25a5f99d31a68c8c18fc370f893e091bc19e6f61470000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000147472616e736665724f70657261746f72736869700000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000046a4cad7a08062f5a67c5bc4aa6d8c8816eff2470000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000010000000000000000000000002f467c697798c24788086e327b0bfd25952105fe000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000414aaeab55123571f2fae033d6d95b814975601c91470bdaf0c5c73c67cc22098d0b03cffdd2b0df7fb329a48bd80679ea17a78f992de05101f996afa169bbe0471c00000000000000000000000000000000000000000000000000000000000000";
    let rpc_url = "https://eth-goerli.g.alchemy.com/v2/DpCscOiv_evEPscGYARI3cOVeJ59CRo8";
    let contract_addr = "0x1577875Dd69f5276AEEabE3540b1F7c64690b3F8";
    let private_key = "84e4de1f09d9e593a9b229aacce492d4874605a0443241a78f2db48b51ce7da9";
    //let signer = OWNER_PRIVATE_KEY.parse::<LocalWallet>()?;
    let signer = private_key.parse::<LocalWallet>()?;
    info!(
        "Call from address {:?}",
        hex::encode(signer.address().as_bytes()).as_str()
    );
    let signer_middleware = Provider::<Http>::try_from(rpc_url)?.with_signer(signer.clone());
    //info!("Default sender {:?}", provider.default_sender());
    let client = Arc::new(signer_middleware);
    let address: Address = contract_addr.parse()?;
    let contract = ScalarGateway::new(address.clone(), client.clone());
    let abi = contract.abi();
    let payload = hex::decode(execute_param)?;
    info!(
        "Payload  in 0x{} with length {}",
        execute_param,
        payload.len()
    );
    info!("Payload out 0x{}", hex::encode(&payload));
    let params = Bytes::from_hex(execute_param)?;
    info!("Params {:?}", &params);
    let contract_call = contract.execute(params);
    let res = contract_call.send().await?.await;
    info!("Call result {:?}", &res);
    Ok(())
}
